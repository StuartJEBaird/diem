(*  START diem helper functions *)cStateCount[c_] :=  Map[Last, Tally[Join[{"_", "0", "1", "2"}, c]]] - 1sStateCount[s_] := cStateCount[Characters[s]]pHetErrOnStateCount[sCount_] :=  Module[{CallTotal = Total[sCount {0, 1, 1, 1}]},  If[CallTotal > 0, {Total[sCount {0, 0, 1, 2}]/(2 CallTotal),     sCount[[3]]/CallTotal, sCount[[1]]/Total[sCount]}, {"NA", "NA",     If[Total[sCount] > 0, sCount[[1]]/Total[sCount], "NA"]}]  ]pHetErrOnString[locusOrIndString_] :=  pHetErrOnStateCount[sStateCount[locusOrIndString]]pHetErrOnChars[charList_] :=  pHetErrOnStateCount[  cStateCount[   charList]](* original code simply used arg I4. Equivalent to this \version with Epsilon=0 *)ModelOfDiagnostic[I4_, OriginalHI_, Epsilon_, verbose_] :=  Module[{RescaledHI, SRHI, WarpSwitch, RescaledHIsWithNAs,    WarpString4, pHI},  If[verbose,    Print[Style["ModelOfDiagnostic Dimensions[I4]: ", Orange],     Dimensions[I4], Total[I4[[1]]]]];  If[Epsilon == 0, I4,      RescaledHI = Select[OriginalHI, # != "NA" &];   If[Length[RescaledHI] <      2,(*if there are less than 2 individuals with computable HI \return the trivial answer*) "NA",    (* otherwise non-trivial answer *)        RescaledHI = (RescaledHI - Min[RescaledHI])/(Max[RescaledHI] -         Min[RescaledHI]);    SRHI = Sort[RescaledHI];    If[verbose,      Print[ListPlot[SRHI, PlotRange -> {0, 1}, Frame -> True,        FrameLabel -> {"Inds sorted by HI'", "HI'"},        PlotLabel -> "ModelOfDiagnostic (fig 1)"]]];    WarpSwitch = Transpose[{       Map[Mean, l2mers[SRHI]],       Drop[SRHI, +1] - Drop[SRHI, -1]       }];    If[verbose,      Print[ListPlot[WarpSwitch, Frame -> True, PlotStyle -> Red,        Filling -> Axis, PlotRange -> All,        FrameLabel -> {"\[CapitalDelta]HI' position on HI'",          "\[CapitalDelta]HI'"},        PlotLabel -> "ModelOfDiagnostic (fig 2)"]]];    WarpSwitch = Sort[WarpSwitch, #1[[2]] > #2[[2]] &][[1, 1]];         RescaledHIsWithNAs =      MultiInsert[RescaledHI, "NA",       Flatten[Position[OriginalHI, "NA"]]];    WarpString4 =      StringJoin[      Table[If[RescaledHIsWithNAs[[i]] == "NA", "_",         If[RescaledHIsWithNAs[[i]] > WarpSwitch, "2", "0"]], {i, 1,         Length[RescaledHIsWithNAs]}]];    If[verbose,      Print["WarpSwitch: ", N[WarpSwitch], ". WarpString: ",       Style[WarpString4, Tiny]]];    WarpString4 =      Total[I4[[1]]]*Map[sStateCount, Characters[WarpString4]];    If[verbose,      Print["Max 10 elements of WarpString4: ",       SmallMat[WarpString4, 10]]];    pHI =      Table[If[RescaledHIsWithNAs[[i]] == "NA",(*        then the value of pHI does not matter (because contributions \to the mixed mode are identical "_" : *)0.5,       (* otherwise *)              If[RescaledHIsWithNAs[[i]] > WarpSwitch,        (RescaledHIsWithNAs[[i]] - WarpSwitch)/(1 - WarpSwitch),        (WarpSwitch - RescaledHIsWithNAs[[i]])/(WarpSwitch)]       ], {i, 1, Length[RescaledHIsWithNAs]}];    If[verbose,      Print[ListPlot[Transpose[{RescaledHIsWithNAs, pHI}],        Frame -> True, PlotStyle -> Red, Filling -> Axis,        PlotRange -> All, FrameLabel -> {"HI'", "\[Beta](HI')"},        PlotLabel -> "ModelOfDiagnostic (fig 3)"]]];    (* return the non-    trivial answer *)    (Epsilon pHI) WarpString4 + (1 -         Epsilon pHI) I4    ]]  ](*  END diem helper functions *)diem[\[CapitalPhi]W_, CompartmentNames_, AllIndCompartmentPloidies_,    datapath_, filedoutputPath_, ChosenInds_, diemMaxIterations_,    Epsilon_] :=    diem[\[CapitalPhi]W, CompartmentNames, AllIndCompartmentPloidies,    datapath, filedoutputPath, ChosenInds, diemMaxIterations, Epsilon,    False];(* default is non verbose \[Rule]                                     \                                    ^^^^ *)diem[\[CapitalPhi]W_, CompartmentNames_, AllIndCompartmentPloidies_,   datapath_, filedoutputPath_, ChosenInds_, diemMaxIterations_,   Epsilon_, verbose_] := Module[{CompartmentDatapaths, vPrint,   GetI4ofOneCompartment, GetI4ofCompartments,   I4, FlatLogI4, Mindex, offsetsM, PolariseAndRankMarker,   RelabelCompartment, NewLabels, PositionsThatChangedPolarity,    NuSimpleLabelling, DeltaSimpleLabelling,   \[CapitalDelta]I4, NuI4, IterationCount, OuterMap, InnerMap,   \[CapitalPhi], \[CapitalDelta]\[CapitalPhi], DIstore = {},    Nu\[CapitalPhi], \[CapitalPhi]tally,   STOREnPositionsThatChangedPolarity = {},    STOREFULLPositionsThatChangedPolarity = {}, I4store = {},   DetectLimitCycleNchangesMatch = False,    DetectLimitCycleChangedPositionsMatch = False,    ActualLimitCycle = False,   ExistingLCcandidate = 0,   V4,   MinInI4, SmallDataI4errorTerm, SmallDataI4errorTermStore = {},   SmallDataErrorTermGoesTo = 1, UpdateEMstateGivenI4,   (* for ploidy-aware HIs *)      I4compartments, \[CapitalDelta]I4compartments, (*PLHI1*)      OriginalHI(*PLHI2*),   (* for Natalia spotted I4 A4 correction*)   A4,    A4compartments, \[CapitalDelta]A4compartments, NuA4compartments,    UpdateM4withDelta, A4errorTermDistributor,   (* only necessary for I4A4 checking *)   I4errorTermDistributor,    NuI4compartments, QI4A4checking = False, UnitMatrix, To4s, NOTo4s,   Nprocessors = 8, ChunkParallelMap, OrderedParallelMap,    TheExportCharacters, TheExportData,   CompartmentPloidies (* for BUGFIX_nPloidiesFix *)   },    (* Housekeeping functions *)    vPrint[l__] := If[verbose, Print[l]];  ChunkParallelMap[f_, arglist_] :=    Module[{argChunks = PartitionPlus[arglist, Nprocessors]},     Print["ChunkParallelMap chunks: ", Map[Length, argChunks]];     Flatten[Table[      ParallelMap[f, argChunks[[i]]], {i, 1, Length[argChunks]}],      1]];  OrderedParallelMap[f_, arglist_] :=    ParallelMap[f, arglist, Method -> "FinestGrained"];  Switch[Length[CompartmentNames],   1, OuterMap = Map; InnerMap = OrderedParallelMap,   _, OuterMap = OrderedParallelMap; InnerMap = Map   ];    (* Data import functions *)    GetI4ofOneCompartment[markerCompartmentpath_, markerlabels_] :=    Module[{ALLmarkersLabelled, emPolarise},    emPolarise[markerNlabel_] :=      If[markerNlabel[[2]] == "1", markerNlabel[[1]],       StringReplace[markerNlabel[[1]], {"0" -> "2", "2" -> "0"}]];(*     Spretus WAS If[markerNlabel[[2]]\[Equal]1, *)        InnerMap[sStateCount,      StringTranspose[       Map[emPolarise,         Transpose[{sImport[markerCompartmentpath],           Characters[markerlabels]}]]][[ChosenInds]]]    ];  GetI4ofOneCompartment[twoArgsAsOne_] :=    Apply[GetI4ofOneCompartment, twoArgsAsOne];  GetI4ofCompartments[markerLabelsForCompartments_] :=      OuterMap[GetI4ofOneCompartment,     Transpose[{CompartmentDatapaths, markerLabelsForCompartments}]];    (* The key tight-loop function *)    PolariseAndRankMarker[origM_, \[CapitalPhi]marker_] :=    Module[{indicesM, Ans, MaxAns, Polarity = "1"(* DEFAULT *)},     indicesM =      ReplaceAll[      Characters[origM], {"_" -> 1, "0" -> 2, "1" -> 3, "2" -> 4}];    Ans =      Map[Total, {FlatLogI4[[indicesM + offsetsM]],        FlatLogI4[[        ReplaceAll[indicesM, {2 -> 4, 4 -> 2}] + offsetsM]]}];    If[\[CapitalPhi]marker == "2", Ans = Reverse[Ans]];    MaxAns = Max[Ans]; If[Ans[[2]] > Ans[[1]], Polarity = "2"];(*     ONLY CHANGE FROM DEFAULT    ^^^ *)    {{Polarity, MaxAns,       MaxAns - Min[Ans]},      Switch[{\[CapitalPhi]marker, Polarity},      {"1", "1"}, "",      {"1", "2"}, StringReplace[origM, {"0" -> "2", "2" -> "0"}],      {"2", "1"}, "",       {"2", "2"}, origM,       _, Print[Style["WOOPS!", Red]]; ""      ]     }    ];  PolariseAndRankMarker[origM\[CapitalPhi]marker_] :=    Apply[PolariseAndRankMarker, origM\[CapitalPhi]marker];      (* Function applying the key tight-  loop function to a data compartment *)    RelabelCompartment[    markerCompartmentpath_, \[CapitalPhi]Compartment_] :=    Module[{NewLabellingC, ChangedStateC, DeltaIndStateCountsC},    NewLabellingC =      PrependRangeLabel[      InnerMap[PolariseAndRankMarker,        Transpose[{StringTranspose[          StringTranspose[sImport[markerCompartmentpath]][[           ChosenInds]]], Characters[\[CapitalPhi]Compartment]}]]];    ChangedStateC = Select[NewLabellingC, #[[-1]] != "" &];    DeltaIndStateCountsC =      If[ChangedStateC == {}, Table[{0, 0, 0, 0}, Length[ChosenInds]],       Map[sStateCount, StringTranspose[Map[Last, ChangedStateC]]]];    {Map[Second, NewLabellingC],      If[ChangedStateC == {}, {DateString[]},       Prepend[Map[First, ChangedStateC], DateString[]]],      DeltaIndStateCountsC}    ];  RelabelCompartment[twoArgsAsOne_] :=    Apply[RelabelCompartment, twoArgsAsOne];    To4s[CxI_] := Partition[Map[Total, Flatten1[CxI]], Length[CxI[[1]]]];  NOTo4s[CxI_] := CxI;  (* The update step *)  UpdateEMstateGivenI4[] := Module[{},    If [verbose,      Print[Style["UpdateEM1: Dimensions[I4]: ", Orange],       Dimensions[I4]]];    I4store = Append[I4store, I4];    ActualLimitCycle =      If[Not[DetectLimitCycleChangedPositionsMatch], False,(*       otherwise *)            Print[Style["MONITOR_LimitCycle: ", Red], SmallMat[Table[         {i, If[i == ExistingLCcandidate, "ExistingLCcandidate", ""],           I4 == I4store[[i]]},         {i, 1, Length[I4store]}]]];      I4 == I4store[[ExistingLCcandidate]]      ];    If[Not[ActualLimitCycle],(* prepare for next iteration *)          MinInI4 = Min[Flatten[I4]];      SmallDataI4errorTerm = Max[0, SmallDataErrorTermGoesTo - MinInI4];     If [verbose,       Print[Style["MinInI4: ", Blue], MinInI4,        Style[". SmallDataErrorTerm:", Blue], SmallDataI4errorTerm]];     SmallDataI4errorTermStore =       Append[SmallDataI4errorTermStore, SmallDataI4errorTerm];     I4 += SmallDataI4errorTerm;     A4compartments += SmallDataI4errorTerm A4errorTermDistributor;     A4 = Total[A4compartments];     OriginalHI = Transpose[Map[pHetErrOnStateCount, A4]][[1]];      If[verbose,       Print[Style["UpdateEM2: Dimensions[I4]: ", Orange],        Dimensions[I4], Total[I4[[1]]]]];     V4 = ModelOfDiagnostic[I4, OriginalHI, Epsilon, verbose];          FlatLogI4 = N[Log[Flatten[V4/Map[Total, V4]]]],     (* otherwise *)          If [verbose, Print[Style["GOOD HALT.", Darker[Green]]]]     ]    ];(* END OF UpdateEMstateGivenI4[] *)    UpdateM4withDelta[M4_, \[CapitalDelta]M4_] :=    Module[{TrM4 = Transpose[M4]},    TrM4[[2]] =      TrM4[[2]] - \[CapitalDelta]M4[[4]] + \[CapitalDelta]M4[[2]];    TrM4[[4]] =      TrM4[[4]] - \[CapitalDelta]M4[[2]] + \[CapitalDelta]M4[[4]];    Transpose[TrM4]    ];    (* ACTION: Data input paths initialisation *)    If [verbose, Print[Style["\!\(\*StyleBox[\"diem\",\nFontSlant->\"Italic\"]\): Initialisation...",      Green]]];  CompartmentDatapaths =    Table[StringJoin[datapath, CompartmentNames[[i]]], {i, 1,      Length[CompartmentNames]}];  vPrint["CompartmentDatapaths: ", Length[CompartmentDatapaths],    TinyMat[CompartmentDatapaths]];    If [verbose,    Print["\[CapitalPhi]W compartment count ", Length[\[CapitalPhi]W],     ". Showing at most 30 elements: ",     SmallMat[     RightFillBlank[      Table[Characters[StringTakeAtMost[\[CapitalPhi]W[[i]], 30]], {i,         1, Length[\[CapitalPhi]W]}]]]]];(*   Spretus WAS TakeAtMost[\[CapitalPhi]W[[i]],30] *)    (* precalcs and inits *)  Mindex = Range[Length[ChosenInds]];  offsetsM = Range[0, 4 (Length[ChosenInds] - 1), 4];(*   BUGFIX_nPloidiesFix \/\/\/ *)    CompartmentPloidies =    Table[AllIndCompartmentPloidies[[i]][[ChosenInds]], {i, 1,      Length[AllIndCompartmentPloidies]}];    (* ACTION: Measure initial state *)    If [verbose, Print["Starting big state counts.."]];  I4compartments = AbsoluteTiming[GetI4ofCompartments[\[CapitalPhi]W]];  If [verbose, Print["I4 : ", I4compartments[[1]], " seconds."]];  I4compartments = I4compartments[[2]];  I4errorTermDistributor = Map[Total, Map[First, I4compartments]];  I4errorTermDistributor =    I4errorTermDistributor/Total[I4errorTermDistributor];  A4errorTermDistributor =    CompartmentPloidies I4errorTermDistributor;  I4 = Total[I4compartments];   A4compartments = CompartmentPloidies*I4compartments;   A4 = Total[A4compartments];  If [verbose,    Print["I4,A4 (max 5 elements shown): ", SmallMat[I4, 5],     SmallMat[Total[A4compartments], 5]]];  UpdateEMstateGivenI4[];  \[CapitalPhi] = \[CapitalPhi]W;    (* ACTION: THE EM interations: *)  IterationCount = 1;  While[Not[ActualLimitCycle] && IterationCount <= diemMaxIterations,   If [verbose, Print[Style["\!\(\*StyleBox[\"diem\",\nFontSlant->\"Italic\"]\): Iteration ", Green],      IterationCount]];      If [verbose, Print["Starting relabelling..."]];(*    polarised by \[CapitalPhi] *)      NewLabels =     AbsoluteTiming[     Transpose[      InnerMap[RelabelCompartment,        Transpose[{CompartmentDatapaths, \[CapitalPhi]}]]]];    If [verbose, Print["...", NewLabels[[1]], " seconds."]];   NewLabels = NewLabels[[2]];   PositionsThatChangedPolarity = Map[DropFirst, NewLabels[[2]]];   If [verbose,     Print[Style["iteration ", Blue], IterationCount, ": ",      SmallMat[Map[First, NewLabels[[2]]]]]];   \[CapitalDelta]I4compartments =(*Map[Transpose,*)NewLabels[[3]];    \[CapitalDelta]A4compartments =     CompartmentPloidies*\[CapitalDelta]I4compartments;    \[CapitalDelta]I4compartments =     Map[Transpose, \[CapitalDelta]I4compartments];    \[CapitalDelta]A4compartments =     Map[Transpose, \[CapitalDelta]A4compartments];    \[CapitalDelta]I4 = Total[\[CapitalDelta]I4compartments];    NewLabels = NewLabels[[1]];      STOREFULLPositionsThatChangedPolarity =     Append[STOREFULLPositionsThatChangedPolarity,      PositionsThatChangedPolarity];   STOREnPositionsThatChangedPolarity =     Append[STOREnPositionsThatChangedPolarity,      Map[Length, PositionsThatChangedPolarity]];      If [verbose,     Print["Lengths of NewLabels,ChangedLabels (compartment sizes, \Nchanged): ", SmallMat[Transpose[{        Map[Length, NewLabels],        Map[Length, PositionsThatChangedPolarity]        }]]]];      If [verbose,     Print["Extracting \[CapitalDelta]\[CapitalPhi],DI..."]]; (*    polarised by \[CapitalPhi] then repolarised *)   \[CapitalDelta]\\[CapitalPhi] = Map[Transpose, NewLabels];   DIstore =     Append[DIstore,      Map[DropFirst, \[CapitalDelta]\[CapitalPhi]]]; \[CapitalDelta]\\[CapitalPhi] =     Map[StringJoin, Map[First, \[CapitalDelta]\[CapitalPhi]]];    If [verbose, Print["Constructing Nu\[CapitalPhi]..."]];   Nu\[CapitalPhi] =     Map[StringTranspose,      Transpose[{\[CapitalPhi], \[CapitalDelta]\[CapitalPhi]}]];   If [verbose,     Print["Nu\[CapitalPhi] Summaries (one for each compartment): ",      Table[      SmallMat[HiTally[Nu\[CapitalPhi][[i]]]], {i, 1,        Length[Nu\[CapitalPhi]]}]]];   (* UPDATE \[CapitalPhi] *)   \[CapitalPhi] =     Map[StringJoin,      ReplaceAll[      Nu\[CapitalPhi], {"11" -> "1", "12" -> "2", "21" -> "2",        "22" -> "1"}]];   If [verbose,     Print["Updated \[CapitalPhi] Summary: ",      Table[SmallMat[HiTally[Characters[\[CapitalPhi][[i]]]]], {i, 1,        Length[\[CapitalPhi]]}]]];      (* START Check for Actual Limit Cycle  -    progressive checks to minimise computation load *)      DetectLimitCycleNchangesMatch =     MemberQ[Drop[STOREnPositionsThatChangedPolarity, -1],      STOREnPositionsThatChangedPolarity[[-1]]];   DetectLimitCycleChangedPositionsMatch =     If[Not[DetectLimitCycleNchangesMatch], False,     ExistingLCcandidate =       Position[Drop[STOREnPositionsThatChangedPolarity, -1],         STOREnPositionsThatChangedPolarity[[-1]]][[1, 1]];     STOREFULLPositionsThatChangedPolarity[[-1]] ==       STOREFULLPositionsThatChangedPolarity[[ExistingLCcandidate]]     ];   If [verbose,     Print[Style[      "{DetectLimitCycleNchangesMatch,\DetectLimitCycleChangedPositionsMatch,ActualLimitCycle}",       Red], {DetectLimitCycleNchangesMatch,       DetectLimitCycleChangedPositionsMatch, ActualLimitCycle}]];   (* END Check for Actual Limit Cycle  -    progressive checks to minimise computation load *)      (* UPDATE I4 *)      NuI4 = UpdateM4withDelta[I4, \[CapitalDelta]I4];   If [verbose,     Print["Comparing old and updated I4s (max 10 comparisons):",      TinyMat[Transpose[{I4, NuI4}], 10]]];   (* UPDATE A4 *)    NuA4compartments =     MapThread[     UpdateM4withDelta, {A4compartments, \\[CapitalDelta]A4compartments}];      I4 = NuI4 - SmallDataI4errorTerm;   A4compartments =     NuA4compartments -      SmallDataI4errorTerm * A4errorTermDistributor; (*    STUDENEC 2021 I4A4 Identity 2 *)   A4 = Total[A4compartments];      UpdateEMstateGivenI4[];   IterationCount += 1   (* Imagine we have entered a limit cycle,    and we are contemplating exiting and outputing answers *)   (* \\[CapitalPhi] is updated. I4 is updated. BUT DI is NOT updated|   I4' *)    (* IFF the limit cycle is 'nothing changes' then DI'\[Equal]DI and \all is well...*)   (* more generally:    we can take DI' from the cycle state AFTER the last occurence of \the match to the current state in the limit cycle *)   ];(*   END While for EM interations *)   {   Table[    Print["Polarisation export ", i];    TheExportCharacters = Characters[\[CapitalPhi][[i]]];    Print["    N[characters]: ", Length[TheExportCharacters]];    TheExportData =(*Parallel*)Table[{       TheExportCharacters[[j]],       DIstore[[ExistingLCcandidate + 1]][[i, 1]][[j]],       DIstore[[ExistingLCcandidate + 1]][[i, 2]][[j]]       }, {j, 1, Length[TheExportCharacters]}];    Print["    Characters matched with DI and support..."];    Export[     StringJoin[filedoutputPath, CompartmentNames[[i]],       ".polarisation.tsv"], TheExportData, "TSV"],    {i, 1, Length[\[CapitalPhi]]}],   Print["Exporting posDeltaPolar... "];   Table[    Export[     StringJoin[filedoutputPath, "posDeltaPolar", ToString[i]],     STOREFULLPositionsThatChangedPolarity[[i]], "TSV"],    {i, 1, Length[STOREFULLPositionsThatChangedPolarity]}],   Print["    posDeltaPolar exported."];   Export[StringJoin[filedoutputPath, "I4.tsv"], I4, "TSV"],   Table[Export[     StringJoin[filedoutputPath, "I4store", ToString[i], ".tsv"], I4,      "TSV"], {i, 1, Length[I4store]}], (* MONITOR_LimitCycle TEMP? *)      Export[StringJoin[filedoutputPath, "SmallDataErrorTerm.tsv"],     SmallDataI4errorTermStore, "TSV"]   }  ]